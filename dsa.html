<!DOCTYPE html>
<html>
<head>
    <title>Informative Showcase Algorithms</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="script.js" defer></script>
</head>

<body>
    <nav class="side-nav">
        <div class="menu-btn">
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        <div class="side-menu">
            <ul>
                <li>
                    <a href="#pseudo-code">Pseudo Code</a>
                    <ul>
                        <li><a href="#if-else">If-Else Statement</a></li>
                        <li><a href="#loops">Loops</a></li>
                        <li><a href="#functions">Functions</a></li>
                        <li><a href="#operations">Operations</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#arrays">Arrays</a>
                    <ul>
                        <li><a href="#array-operations">Basic Operations</a></li>
                        <li><a href="#bubble-sort">Bubble Sort</a></li>
                        <li><a href="#quick-sort">Quick Sort</a></li>
                        <li><a href="#selection-sort">Selection Sort</a></li>
                        <li><a href="#counting-sort">Counting Sort</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#graphs">Graphs</a>
                    <ul>
                        <li><a href="#graph-representation">Representation</a></li>
                        <li><a href="#graph-traversal">Traversal</a>
                            <ul>
                                <li><a href="#bfs">BFS</a></li>
                                <li><a href="#dfs">DFS</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#linked-lists">Linked Lists</a>
                    <ul>
                        <li><a href="#singly-linked">Singly Linked</a></li>
                        <li><a href="#doubly-linked">Doubly Linked</a></li>
                        <li><a href="#circular-linked">Circular Linked</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#trees">Trees</a>
                    <ul>
                        <li><a href="#binary-tree">Binary Trees</a></li>
                        <ul>
                            <!-- Adding Binary Tree Operations link under Binary Trees -->
                            <li><a href="#binary-tree-operations">Binary Tree Operations</a></li>
                        </ul>
                        <li><a href="#binary-search-tree">Binary Search Trees</a></li>
                        <li><a href="#avl-tree">AVL Trees</a></li>
                        <li><a href="#red-black-tree">Red-Black Trees</a></li>
                    </ul>
    
    <div id="wrapper">
        <header id="header">
            <div class="logo">
                <h1>I.S.A.</h1>
            </div>
            <div class="content">
                <div class="inner">
                    <h2>Informative Showcase Algorithms</h2>
                    <p>Data Structures and Algorithms</p>
                </div>
            </div>
        </header>

        <section>
            <h1 id="pseudo-code">Pseudo Code</h1>
            <p>Pseudo code is a high-level description of an algorithm or process that is written in a way that is easy to understand. It is not actual code but helps in planning and designing the logic before implementing it in a specific programming language.</p>

            <h2 id="if-else">If-Else Statement</h2>
            <div class="pseudo-code">
                IF condition THEN<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Perform action<br>
                ELSE<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Perform alternative action<br>
                ENDIF
            </div>

            <h2 id="loops">Loops</h2>
            <div class="pseudo-code">
                FOR each item in collection DO<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Perform action<br>
                ENDFOR
            </div>

            <h2 id="functions">Functions</h2>
            <div class="pseudo-code">
                FUNCTION name(parameters)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;Perform action<br>
                &nbsp;&nbsp;&nbsp;&nbsp;RETURN result<br>
                END FUNCTION
            </div>

            <h2 id="operations">Operations</h2>
            <div class="pseudo-code">
                INPUT firstNumber, secondNumber<br>
                result = firstNumber + secondNumber<br>
                OUTPUT result<br>
            </div>
        </section>
    </div>
</body>
</html>

        <div id="main">
            <article id="arrays">
                <h2>Arrays</h2>
                <p>Arrays are fundamental data structures that store elements in contiguous memory locations. They allow for efficient access to elements using an index.</p>
                
                <h3>Example of an Array</h3>
                <p>Below is an example of a simple array:</p>
                <pre>
                [10, 20, 30, 40, 50]
                </pre>
                <p>In this array:</p>
                <ul>
                    <li>The array contains five elements: <strong>10</strong>, <strong>20</strong>, <strong>30</strong>, <strong>40</strong>, and <strong>50</strong>.</li>
                    <li>Each element can be accessed using its index, starting from <strong>0</strong>.</li>
                    <li>For example, the element at index <strong>2</strong> is <strong>30</strong>.</li>
                </ul>
            </article>
        

            <article id="array-operations">
                <h2>Basic Array Operations</h2>
                <div class="array-demo">
                    <div class="array-container">
                        <div id="array-display"></div>
                    </div>
                    <div class="controls">
                        <button onclick="generateRandomArrayBasic()">Generate Random Array</button>
                        <input type="number" id="arrayInput" placeholder="Enter a number">
                        <input type="number" id="arrayIndex" placeholder="Enter index">
                        <button onclick="insertElement()">Insert</button>
                        <button onclick="deleteElement()">Delete</button>
                        <button onclick="searchElement()">Search</button>
                    </div>
                    <div id="operation-result"></div>
                </div>
                <div class="code-explanation">
                    <h3>Python Implementation</h3>
                    <p>Here's how these basic array operations can be implemented in Python. In Python, lists are used as dynamic arrays and provide built-in methods for these operations:</p>
                    <pre><code class="language-python">
# Basic Array Operations in Python

# Initialize an array
array = []

# Generate random array
import random
def generate_random_array():
    return [random.randint(1, 100) for _ in range(10)]

# Insert element at specific index
def insert_element(arr, value, index):
    arr.insert(index, value)
    return arr

# Delete element at specific index
def delete_element(arr, index):
    if 0 <= index < len(arr):
        return arr.pop(index)
    return None

# Search for element
def search_element(arr, value):
    try:
        return arr.index(value)
    except ValueError:
        return -1

# Example usage:
array = generate_random_array()
print("Initial array:", array)

# Insert 42 at index 2
array = insert_element(array, 42, 2)
print("After insertion:", array)

# Delete element at index 3
deleted = delete_element(array, 3)
print("After deletion:", array)

# Search for element 42
position = search_element(array, 42)
print("42 found at index:", position)
                    </code></pre>
                </div>
            </article>

            <article id="bubble-sort">
                <h2>Bubble Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="bubble-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayBubble()">Generate Random Array</button>
                        <button onclick="bubbleSort()">Bubble Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Bubble Sort Algorithm</h3>
                    <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

            <article id="quick-sort">
                <h2>Quick Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="quick-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayQuick()">Generate Random Array</button>
                        <button onclick="quickSort()">Quick Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Quick Sort Algorithm</h3>
                    <p>Quick Sort is an efficient, in-place sorting algorithm that uses a divide-and-conquer strategy to sort elements.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = quick_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

            <article id="selection-sort">
                <h2>Selection Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="selection-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArraySelection()">Generate Random Array</button>
                        <button onclick="selectionSort()">Selection Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Selection Sort Algorithm</h3>
                    <p>Selection Sort is a simple sorting algorithm that divides the input into a sorted and unsorted region, and repeatedly selects the smallest element from the unsorted region to add to the sorted region.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = selection_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

            <article id="graphs">
                <h2>Graphs</h2>
                <p>Graphs are collections of nodes (or vertices) connected by edges. They are used to represent relationships between pairs of objects. Graphs can be directed or undirected, weighted or unweighted, and are widely used in various applications such as social networks, transportation systems, and network topology.</p>
                
                <h3>Example of a Graph</h3>
                <p>Below is an example of a simple undirected graph:</p>
                <pre>
                    A -- B
                    |  / |
                    | /  |
                    C -- D
                </pre>
                <p>In this graph:</p>
                <ul>
                    <li><strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong> are the vertices.</li>
                    <li>Edges connect the vertices, indicating relationships.</li>
                    <li>This graph is undirected, meaning the connections have no direction.</li>
                </ul>
            </article>

            <article id="graph-representation">
                <h2>Graph Representation</h2>
                <p>Graphs can be represented in various ways, primarily through adjacency lists and adjacency matrices:</p>
                
                <h3>1. Adjacency List</h3>
                <p>This representation uses an array of lists. Each index of the array represents a vertex, and each element in the list at that index represents the vertices that are adjacent to it. This is space-efficient for sparse graphs.</p>
                <pre>
                A: [B, C]
                B: [A, D]
                C: [A, D]
                D: [B, C]
                </pre>
                <p>In this adjacency list:</p>
                <ul>
                    <li><strong>A</strong> is connected to <strong>B</strong> and <strong>C</strong>.</li>
                    <li><strong>B</strong> is connected to <strong>A</strong> and <strong>D</strong>.</li>
                    <li><strong>C</strong> is connected to <strong>A</strong> and <strong>D</strong>.</li>
                    <li><strong>D</strong> is connected to <strong>B</strong> and <strong>C</strong>.</li>
                </ul>

                <h3>2. Adjacency Matrix</h3>
                <p>This representation uses a 2D array where the rows and columns represent vertices. A cell in the matrix is marked if there is an edge between the corresponding vertices. This is useful for dense graphs but can consume more space.</p>
                <pre>
                    A B C D
                  A 0 1 1 0
                  B 1 0 0 1
                  C 1 0 0 1
                  D 0 1 1 0
                </pre>
                <p>In this adjacency matrix:</p>
                <ul>
                    <li>A <strong>1</strong> indicates an edge between the vertices, while a <strong>0</strong> indicates no edge.</li>
                    <li>The matrix is symmetric for undirected graphs.</li>
                    <li>For example, the entry at row <strong>A</strong> and column <strong>B</strong> is <strong>1</strong>, indicating an edge between <strong>A</strong> and <strong>B</strong>.</li>
                </ul>
            </article>

            <article id="graph-traversal">
                <h2>Graph Traversal</h2>
                <p>Graph traversal is the process of visiting each vertex in a graph. There are two primary methods for traversing a graph: Breadth-First Search (BFS) and Depth-First Search (DFS).</p>
                
                <h3>Breadth-First Search (BFS)</h3>
                <p>BFS explores neighboring vertices before moving to the next level using a queue. It is effective for finding the shortest path in unweighted graphs.</p>
                <pre>
                Example Graph:
                    A
                   / \
                  B   C
                 / \   \
                D   E   F

                BFS Traversal starting from A: A, B, C, D, E, F
                </pre>
                <p>In this BFS traversal:</p>
                <ul>
                    <li>Start at the root node <strong>A</strong>.</li>
                    <li>Visit all neighbors of <strong>A</strong> (i.e., <strong>B</strong> and <strong>C</strong>).</li>
                    <li>Then visit the neighbors of <strong>B</strong> (i.e., <strong>D</strong> and <strong>E</strong>) and the neighbor of <strong>C</strong> (i.e., <strong>F</strong>).</li>
                </ul>

                <h3>Depth-First Search (DFS)</h3>
                <p>DFS explores as far as possible along each branch before backtracking using a stack. It is useful for detecting cycles and exploring connected components in a graph.</p>
                <pre>
                Example Graph:
                    A
                   / \
                  B   C
                 / \   \
                D   E   F

                DFS Traversal starting from A: A, B, D, E, C, F
                </pre>
                <p>In this DFS traversal:</p>
                <ul>
                    <li>Start at the root node <strong>A</strong>.</li>
                    <li>Go as deep as possible along the left branch (to <strong>B</strong>, then to <strong>D</strong>).</li>
                    <li>Backtrack to <strong>B</strong>, then visit <strong>E</strong>, and backtrack to <strong>A</strong>.</li>
                    <li>Finally, visit <strong>C</strong> and then <strong>F</strong>.</li>
                </ul>
            </article>

            <article id="bfs">
                <h2>Breadth-First Search (BFS)</h2>
                <p>BFS explores neighboring vertices before moving to the next level using a queue. It is effective for finding the shortest path in unweighted graphs.</p>

                <p>Here’s how BFS works:</p>
                <ol>
                    <li>Start at the root node and mark it as visited.</li>
                    <li>Enqueue the root node into a queue.</li>
                    <li>While the queue is not empty:</li>
                    <ul>
                        <li>Dequeue a node from the front of the queue.</li>
                        <li>Visit all its unvisited neighbors, mark them as visited, and enqueue them.</li>
                    </ul>
                </ol>

                <p>Example Graph:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>

                <p>BFS Traversal starting from A:</p>
                <pre>
1. Start at A: [A]
2. Visit neighbors of A: [B, C]
3. Visit neighbors of B: [D, E]
4. Visit neighbor of C: [F]
                </pre>

                <p>Final BFS Traversal Order: A, B, C, D, E, F</p>

                <h4>Visualizer</h4>
                <p>Below is a simple visual representation of the BFS traversal:</p>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightblue" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>

                        <circle cx="100" cy="150" r="20" fill="lightgreen" />
                        <text x="100" y="155" text-anchor="middle" font-size="16">B</text>

                        <circle cx="300" cy="150" r="20" fill="lightgreen" />
                        <text x="300" y="155" text-anchor="middle" font-size="16">C</text>

                        <circle cx="50" cy="250" r="20" fill="lightcoral" />
                        <text x="50" y="255" text-anchor="middle" font-size="16">D</text>

                        <circle cx="150" cy="250" r="20" fill="lightcoral" />
                        <text x="150" y="255" text-anchor="middle" font-size="16">E</text>

                        <circle cx="250" cy="250" r="20" fill="lightcoral" />
                        <text x="250" y="255" text-anchor="middle" font-size="16">F</text>

                        <line x1="200" y1="70" x2="100" y2="130" stroke="black" />
                        <line x1="200" y1="70" x2="300" y2="130" stroke="black" />
                        <line x1="100" y1="170" x2="50" y2="230" stroke="black" />
                        <line x1="100" y1="170" x2="150" y2="230" stroke="black" />
                        <line x1="300" y1="170" x2="250" y2="230" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="dfs">
                <h2>Depth-First Search (DFS)</h2>
                <p>DFS explores as far as possible along each branch before backtracking using a stack. It is useful for detecting cycles and exploring connected components in a graph.</p>

                <p>Here’s how DFS works:</p>
                <ol>
                    <li>Start at the root node and mark it as visited.</li>
                    <li>Push the root node onto a stack.</li>
                    <li>While the stack is not empty:</li>
                    <ul>
                        <li>Pop a node from the top of the stack.</li>
                        <li>Visit all its unvisited neighbors, mark them as visited, and push them onto the stack.</li>
                    </ul>
                </ol>

                <p>Example Graph:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>

                <p>DFS Traversal starting from A:</p>
                <pre>
1. Start at A: [A]
2. Visit B: [A, B]
3. Visit D: [A, B, D]
4. Backtrack to B, visit E: [A, B, E]
5. Backtrack to A, visit C: [A, C]
6. Visit F: [A, C, F]
                </pre>

                <p>Final DFS Traversal Order: A, B, D, E, C, F</p>

                <h4>Visualizer</h4>
                <p>Below is a simple visual representation of the DFS traversal:</p>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightblue" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>

                        <circle cx="100" cy="150" r="20" fill="lightgreen" />
                        <text x="100" y="155" text-anchor="middle" font-size="16">B</text>

                        <circle cx="300" cy="150" r="20" fill="lightgreen" />
                        <text x="300" y="155" text-anchor="middle" font-size="16">C</text>

                        <circle cx="50" cy="250" r="20" fill="lightcoral" />
                        <text x="50" y="255" text-anchor="middle" font-size="16">D</text>

                        <circle cx="150" cy="250" r="20" fill="lightcoral" />
                        <text x="150" y="255" text-anchor="middle" font-size="16">E</text>

                        <circle cx="250" cy="250" r="20" fill="lightcoral" />
                        <text x="250" y="255" text-anchor="middle" font-size="16">F</text>

                        <line x1="200" y1="70" x2="100" y2="130" stroke="black" />
                        <line x1="200" y1="70" x2="300" y2="130" stroke="black" />
                        <line x1="100" y1="170" x2="50" y2="230" stroke="black" />
                        <line x1="100" y1="170" x2="150" y2="230" stroke="black" />
                        <line x1="300" y1="170" x2="250" y2="230" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="shortest-path">
                <h2>Shortest Path</h2>
                <p>The shortest path from vertex D to vertex F in the Graph above is D->E->C->F, with a total path weight of 2+4+4=10. Other paths from D to F are also possible, but they have a higher total weight, so they can not be considered to be the shortest path.</p>
                <img src="SHORTESTPATH.png" alt="shortest">
            </article>

            <h2 id="shortest-path">Shortest Path (Dijkstra's Algorithm)</h2>
            <pre>
                Dijkstra(Graph, source):
                    for each vertex v in Graph:
                        distance[v] = INFINITY
                        previous[v] = UNDEFINED
                    distance[source] = 0
                    Q = all vertices in Graph
                    while Q is not empty:
                        u = vertex in Q with smallest distance[u]
                        remove u from Q
                        for each neighbor v of u:
                            alt = distance[u] + weight(u, v)
                            if alt < distance[v]:
                                distance[v] = alt
                                previous[v] = u
                    return distance, previous
            </pre>


            <article id="linked-lists">
                <h2>Linked Lists</h2>
                <p>A linked list consists of nodes, where each node contains data and a pointer (or link) to the next node in the sequence.</p>
                
                <h3>Example of a Singly Linked List</h3>
                <p>Below is an example of a simple singly linked list:</p>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -> NULL
                </pre>
                <p>In this singly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to the next node in the list.</li>
                    <li>The last node points to <strong>NULL</strong>, indicating the end of the list.</li>
                </ul>
            </article>

            <article id="singly-linked">
                <h2>Singly Linked List</h2>
                <p>A singly linked list consists of nodes where each node contains data and a pointer to the next node in the sequence.</p>
                
                <h3>Example of a Singly Linked List</h3>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -> NULL
                </pre>
                <p>In this singly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to the next node in the list.</li>
                    <li>The last node points to <strong>NULL</strong>, indicating the end of the list.</li>
                </ul>


                <h4>Visualizer</h4>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="300" height="100">
                        <circle cx="50" cy="50" r="20" fill="lightblue" />
                        <text x="50" y="55" text-anchor="middle" font-size="16">A</text>
                        <line x1="70" y1="50" x2="130" y2="50" stroke="black" />
                        <circle cx="150" cy="50" r="20" fill="lightblue" />
                        <text x="150" y="55" text-anchor="middle" font-size="16">B</text>
                        <line x1="170" y1="50" x2="230" y2="50" stroke="black" />
                        <circle cx="250" cy="50" r="20" fill="lightblue" />
                        <text x="250" y="55" text-anchor="middle" font-size="16">C</text>
                        <line x1="270" y1="50" x2="330" y2="50" stroke="black" />
                        <circle cx="350" cy="50" r="20" fill="lightblue" />
                        <text x="350" y="55" text-anchor="middle" font-size="16">D</text>
                        <line x1="370" y1="50" x2="400" y2="50" stroke="black" />
                        <text x="390" y="55" text-anchor="middle" font-size="16">NULL</text>
                    </svg>
                </div>
            </article>

            <article id="doubly-linked">
                <h2>Doubly Linked List</h2>
                <p>A doubly linked list consists of nodes where each node contains data and two pointers: one pointing to the next node and another pointing to the previous node.</p>
                
                <h3>Example of a Doubly Linked List</h3>
                <pre>
                NULL <- [A] <-> [B] <-> [C] <-> [D] -> NULL
                </pre>
                <p>In this doubly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to both the next and previous nodes.</li>
                    <li>The first node's previous pointer points to <strong>NULL</strong>, and the last node's next pointer points to <strong>NULL</strong>.</li>
                </ul>

                <h4>Visualizer</h4>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="100">
                        <text x="10" y="55" text-anchor="middle" font-size="16">NULL</text>
                        <line x1="50" y1="50" x2="100" y2="50" stroke="black" />
                        <circle cx="100" cy="50" r="20" fill="lightgreen" />
                        <text x="100" y="55" text-anchor="middle" font-size="16">A</text>
                        <line x1="120" y1="50" x2="180" y2="50" stroke="black" />
                        <circle cx="200" cy="50" r="20" fill="lightgreen" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">B</text>
                        <line x1="220" y1="50" x2="280" y2="50" stroke="black" />
                        <circle cx="300" cy="50" r="20" fill="lightgreen" />
                        <text x="300" y="55" text-anchor="middle" font-size="16">C</text>
                        <line x1="320" y1="50" x2="380" y2="50" stroke="black" />
                        <circle cx="400" cy="50" r="20" fill="lightgreen" />
                        <text x="400" y="55" text-anchor="middle" font-size="16">D</text>
                        <line x1="420" y1="50" x2="470" y2="50" stroke="black" />
                        <text x="480" y="55" text-anchor="middle" font-size="16">NULL</text>
                    </svg>
                </div>
            </article>

            <article id="circular-linked">
                <h2>Circular Linked List</h2>
                <p>A circular linked list is a variation where the last node points back to the first node, forming a circle.</p>
                
                <h3>Example of a Circular Linked List</h3>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -+
                          ^                     |
                          +---------------------+
                </pre>
                <p>In this circular linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>The last node points back to the head, creating a circular structure.</li>
                    <li>This allows for continuous traversal of the list without encountering <strong>NULL</strong>.</li>
                </ul>

                <h4>Visualizer</h4>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightcoral" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>
                        <line x1="220" y1="50" x2="280" y2="50" stroke="black" />
                        <circle cx="300" cy="50" r="20" fill="lightcoral" />
                        <text x="300" y="55" text-anchor="middle" font-size="16">B</text>
                        <line x1="320" y1="50" x2="380" y2="50" stroke="black" />
                        <circle cx="400" cy="50" r="20" fill="lightcoral" />
                        <text x="400" y="55" text-anchor="middle" font-size="16">C</text>
                        <line x1="420" y1="50" x2="480" y2="50" stroke="black" />
                        <circle cx="500" cy="50" r="20" fill="lightcoral" />
                        <text x="500" y="55" text-anchor="middle" font-size="16">D</text>
                        <line x1="520" y1="50" x2="200" y2="50" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="binary-tree">
                <h2>Binary Tree</h2>
                <p>A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.</p>
                
                <h3>Example of a Binary Tree</h3>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>
                <p>In this binary tree:</p>
                <ul>
                    <li><strong>A</strong> is the root node.</li>
                    <li><strong>B</strong> and <strong>C</strong> are the children of <strong>A</strong>.</li>
                    <li><strong>D</strong> and <strong>E</strong> are the children of <strong>B</strong>.</li>
                    <li><strong>F</strong> is the child of <strong>C</strong>.</li>
                </ul>
            
                <h3>Binary Tree Operations</h3>
                <p>The common operations on a binary tree include:</p>
                <ul>
                    <li><strong>Insertion:</strong> Adds a node to the tree.</li>
                    <li><strong>Traversal:</strong> Visits each node in the tree. Common methods are In-order, Pre-order, and Post-order traversal.</li>
                    <li><strong>Deletion:</strong> Removes a node from the tree.</li>
                </ul>
            
                <h4>Insertion</h4>
                <pre>
                    Insert(value):
                        create a new node with the value
                        if tree is empty:
                            set root to the new node
                        else:
                            traverse the tree to find an empty spot and insert the new node
                </pre>
            
                <h4>Traversal</h4>
                <p>Traversal methods in binary trees:</p>
                <ul>
                    <li><strong>Pre-order:</strong> Visit root, traverse left subtree, traverse right subtree.</li>
                    <li><strong>In-order:</strong> Traverse left subtree, visit root, traverse right subtree.</li>
                    <li><strong>Post-order:</strong> Traverse left subtree, traverse right subtree, visit root.</li>
                </ul>
            
                <h4>Deletion</h4>
                <pre>
                    Delete(value):
                        find the node with the value
                        if the node is a leaf (no children):
                            remove the node
                        if the node has one child:
                            replace the node with its child
                        if the node has two children:
                            find the inorder successor, replace the node with it, and delete the successor
                </pre>
            
                <h4>Binary Tree JavaScript Implementation</h4>
                <pre>
                    class BinaryTree {
                        constructor(value) {
                            this.value = value;
                            this.left = null;
                            this.right = null;
                        }
            
                        insert(value) {
                            if (value < this.value) {
                                if (this.left === null) {
                                    this.left = new BinaryTree(value);
                                } else {
                                    this.left.insert(value);
                                }
                            } else {
                                if (this.right === null) {
                                    this.right = new BinaryTree(value);
                                } else {
                                    this.right.insert(value);
                                }
                            }
                        }
            
                        traverseInOrder() {
                            let result = [];
                            if (this.left) result = result.concat(this.left.traverseInOrder());
                            result.push(this.value);
                            if (this.right) result = result.concat(this.right.traverseInOrder());
                            return result;
                        }
            
                        traversePreOrder() {
                            let result = [this.value];
                            if (this.left) result = result.concat(this.left.traversePreOrder());
                            if (this.right) result = result.concat(this.right.traversePreOrder());
                            return result;
                        }
            
                        traversePostOrder() {
                            let result = [];
                            if (this.left) result = result.concat(this.left.traversePostOrder());
                            if (this.right) result = result.concat(this.right.traversePostOrder());
                            result.push(this.value);
                            return result;
                        }
            
                        delete(value) {
                            if (value < this.value) {
                                if (this.left) {
                                    this.left = this.left.delete(value);
                                }
                            } else if (value > this.value) {
                                if (this.right) {
                                    this.right = this.right.delete(value);
                                }
                            } else {
                                // Node to be deleted found
                                if (!this.left && !this.right) {
                                    return null; // No children
                                } else if (!this.left) {
                                    return this.right; // One child (right)
                                } else if (!this.right) {
                                    return this.left; // One child (left)
                                }
            
                                // Node with two children
                                let minValueNode = this.right.findMin();
                                this.value = minValueNode.value;
                                this.right = this.right.delete(minValueNode.value);
                            }
                            return this;
                        }
            
                        findMin() {
                            let current = this;
                            while (current.left) {
                                current = current.left;
                            }
                            return current;
                        }
                    }
            
                    // Example Usage:
                    let tree = new BinaryTree(10);
                    tree.insert(5);
                    tree.insert(15);
                    tree.insert(3);
                    tree.insert(7);
                    tree.insert(12);
                    tree.insert(18);
            
                    console.log('In-order traversal:', tree.traverseInOrder()); // [3, 5, 7, 10, 12, 15, 18]
                    console.log('Pre-order traversal:', tree.traversePreOrder()); // [10, 5, 3, 7, 15, 12, 18]
                    console.log('Post-order traversal:', tree.traversePostOrder()); // [3, 7, 5, 12, 18, 15, 10]
            
                    tree.delete(5); // Deletes node with value 5
                    console.log('In-order traversal after deletion:', tree.traverseInOrder()); // [3, 7, 10, 12, 15, 18]
                </pre>
            </article>
            
            <article id="binary-search-tree">
                <h2>Binary Search Tree (BST)</h2>
                <p>A binary search tree is a binary tree with the additional condition that for each node, the left subtree contains only nodes with values less than the node’s value, and the right subtree only nodes with values greater than the node’s value.</p>
                
                <h3>Example of a Binary Search Tree</h3>
                <pre>
                    4
                   / \
                  2   6
                 / \ / \
                1  3 5  7
                </pre>
                <p>In this binary search tree:</p>
                <ul>
                    <li>The left child of <strong>4</strong> is <strong>2</strong>, and the right child is <strong>6</strong>.</li>
                    <li>All values in the left subtree of <strong>4</strong> are less than <strong>4</strong>, and all values in the right subtree are greater.</li>
                </ul>
            
                <h4>Insert a Value into the BST:</h4>
                <input type="number" id="bst-input" placeholder="Enter a value">
                <button onclick="insertBST()">Insert</button>
                <div id="bst-output"></div>
            </article>
            
            <article id="avl-tree">
                <h2>AVL Tree</h2>
                <p>An AVL tree is a self-balancing binary search tree where the difference in heights between the left and right subtrees for any node is at most one. This ensures O(log n) time complexity for search, insert, and delete operations.</p>
                
                <h3>Example of an AVL Tree</h3>
                <pre>
                    30
                   /  \
                  20   40
                 / \    \
                10  25   50
                </pre>
                <p>In this AVL tree:</p>
                <ul>
                    <li>The tree is balanced, with the height difference between left and right subtrees for each node being at most one.</li>
                </ul>
            
                <h4>Insert a Value into the AVL Tree:</h4>
                <input type="number" id="avl-input" placeholder="Enter a value">
                <button onclick="insertAVL()">Insert</button>
                <div id="avl-output"></div>
            </article>
            
            // Binary Search Tree Operations
            class BSTNode {
                constructor(value) {
                    this.value = value;
                    this.left = null;
                    this.right = null;
                }
            }
            
            let bstRoot = null;
            
            // Insert value in the Binary Search Tree
            function insertBST() {
                const value = parseInt(document.getElementById('bst-input').value);
                if (!value) {
                    alert("Please enter a valid number");
                    return;
                }
                bstRoot = insertBSTNode(bstRoot, value);
                displayBST(bstRoot);
            }
            
            // Insert helper function for BST
            function insertBSTNode(root, value) {
                if (root === null) {
                    return new BSTNode(value);
                }
                if (value < root.value) {
                    root.left = insertBSTNode(root.left, value);
                } else {
                    root.right = insertBSTNode(root.right, value);
                }
                return root;
            }
            
            // Display the Binary Search Tree in the DOM
            function displayBST(root) {
                if (!root) return;
                let output = `Node: ${root.value}`;
                if (root.left) {
                    output += `<br>Left: ${root.left.value}`;
                }
                if (root.right) {
                    output += `<br>Right: ${root.right.value}`;
                }
                document.getElementById('bst-output').innerHTML = output;
            }
            
            
            // AVL Tree Operations
            class AVLNode {
                constructor(value) {
                    this.value = value;
                    this.left = null;
                    this.right = null;
                    this.height = 1;
                }
            }
            
            let avlRoot = null;
            
            // Insert value in the AVL Tree
            function insertAVL() {
                const value = parseInt(document.getElementById('avl-input').value);
                if (!value) {
                    alert("Please enter a valid number");
                    return;
                }
                avlRoot = insertAVLNode(avlRoot, value);
                displayAVL(avlRoot);
            }
            
            // Insert helper function for AVL Tree
            function insertAVLNode(root, value) {
                if (root === null) {
                    return new AVLNode(value);
                }
                if (value < root.value) {
                    root.left = insertAVLNode(root.left, value);
                } else if (value > root.value) {
                    root.right = insertAVLNode(root.right, value);
                } else {
                    return root; // Duplicate values are not allowed
                }
            
                root.height = 1 + Math.max(height(root.left), height(root.right));
            
                // Get balance factor
                const balance = getBalance(root);
            
                // Balance the node if needed
                if (balance > 1 && value < root.left.value) {
                    return rightRotate(root); // Left-Left case
                }
                if (balance < -1 && value > root.right.value) {
                    return leftRotate(root); // Right-Right case
                }
                if (balance > 1 && value > root.left.value) {
                    root.left = leftRotate(root.left); // Left-Right case
                    return rightRotate(root); 
                }
                if (balance < -1 && value < root.right.value) {
                    root.right = rightRotate(root.right); // Right-Left case
                    return leftRotate(root);
                }
            
                return root;
            }
            
            // Height of the node
            function height(node) {
                return node ? node.height : 0;
            }
            
            // Get balance factor of the node
            function getBalance(node) {
                return node ? height(node.left) - height(node.right) : 0;
            }
            
            // Right Rotate operation
            function rightRotate(y) {
                let x = y.left;
                let T2 = x.right;
            
                // Perform rotation
                x.right = y;
                y.left = T2;
            
                // Update heights
                y.height = 1 + Math.max(height(y.left), height(y.right));
                x.height = 1 + Math.max(height(x.left), height(x.right));
            
                return x;
            }
            
            // Left Rotate operation
            function leftRotate(x) {
                let y = x.right;
                let T2 = y.left;
            
                // Perform rotation
                y.left = x;
                x.right = T2;
            
                // Update heights
                x.height = 1 + Math.max(height(x.left), height(x.right));
                y.height = 1 + Math.max(height(y.left), height(y.right));
            
                return y;
            }
            
            // Display the AVL Tree in the DOM
            function displayAVL(root) {
                if (!root) return;
                let output = `Node: ${root.value}, Height: ${root.height}`;
                if (root.left) {
                    output += `<br>Left: ${root.left.value}`;
                }
                if (root.right) {
                    output += `<br>Right: ${root.right.value}`;
                }
                document.getElementById('avl-output').innerHTML = output;
            }
                        
            
            <section>
                <article id="red-black-tree">
                    <h2>Red-Black Tree</h2>
                    <p>A red-black tree is a type of self-balancing binary search tree where each node has an extra bit for denoting the color of the node, either red or black. This ensures that the tree remains approximately balanced during insertions and deletions.</p>
                    
                    <h3>Example of a Red-Black Tree</h3>
                    <pre>
                        10 (B)
                       /    \
                     5(R)   15(R)
                    / \      \
                   3(B)  7(B) 20(B)
                    </pre>
                    <p>In this red-black tree:</p>
                    <ul>
                        <li>Every node is either red or black.</li>
                        <li>The root is always black.</li>
                        <li>Red nodes cannot have red children (no two reds in a row).</li>
                        <li>Every path from a node to its descendant NULL nodes must have the same number of black nodes.</li>
                    </ul>
                    
                    <h3>Insert Values into Red-Black Tree</h3>
                    <button onclick="insertValues()">Insert Values</button>
                    <p id="tree-output"></p>
                </article>
            </section>
        </div>
    
        <script>
        // Red-Black Tree Node
        class Node {
            constructor(data) {
                this.data = data;
                this.color = 'red'; // New nodes are always red
                this.left = null;
                this.right = null;
                this.parent = null;
            }
        }
    
        // Red-Black Tree
        class RedBlackTree {
            constructor() {
                this.TNULL = new Node(0);
                this.TNULL.color = 'black'; // TNULL is always black
                this.root = this.TNULL;
            }
    
            // Left Rotate
            leftRotate(x) {
                let y = x.right;
                x.right = y.left;
                if (y.left !== this.TNULL) {
                    y.left.parent = x;
                }
                y.parent = x.parent;
                if (x.parent === null) {
                    this.root = y;
                } else if (x === x.parent.left) {
                    x.parent.left = y;
                } else {
                    x.parent.right = y;
                }
                y.left = x;
                x.parent = y;
            }
    
            // Right Rotate
            rightRotate(x) {
                let y = x.left;
                x.left = y.right;
                if (y.right !== this.TNULL) {
                    y.right.parent = x;
                }
                y.parent = x.parent;
                if (x.parent === null) {
                    this.root = y;
                } else if (x === x.parent.right) {
                    x.parent.right = y;
                } else {
                    x.parent.left = y;
                }
                y.right = x;
                x.parent = y;
            }
    
            // Fix Violations after insertion
            fixInsert(k) {
                let u;
                while (k.parent.color === 'red') {
                    if (k.parent === k.parent.parent.right) {
                        u = k.parent.parent.left;
                        if (u.color === 'red') {
                            u.color = 'black';
                            k.parent.color = 'black';
                            k.parent.parent.color = 'red';
                            k = k.parent.parent;
                        } else {
                            if (k === k.parent.left) {
                                k = k.parent;
                                this.rightRotate(k);
                            }
                            k.parent.color = 'black';
                            k.parent.parent.color = 'red';
                            this.leftRotate(k.parent.parent);
                        }
                    } else {
                        u = k.parent.parent.right;
                        if (u.color === 'red') {
                            u.color = 'black';
                            k.parent.color = 'black';
                            k.parent.parent.color = 'red';
                            k = k.parent.parent;
                        } else {
                            if (k === k.parent.right) {
                                k = k.parent;
                                this.leftRotate(k);
                            }
                            k.parent.color = 'black';
                            k.parent.parent.color = 'red';
                            this.rightRotate(k.parent.parent);
                        }
                    }
                    if (k === this.root) {
                        break;
                    }
                }
                this.root.color = 'black';
            }
    
            // Insertion
            insert(key) {
                let node = new Node(key);
                node.parent = null;
                node.data = key;
                node.left = this.TNULL;
                node.right = this.TNULL;
                node.color = 'red';
    
                let y = null;
                let x = this.root;
    
                while (x !== this.TNULL) {
                    y = x;
                    if (node.data < x.data) {
                        x = x.left;
                    } else {
                        x = x.right;
                    }
                }
    
                node.parent = y;
                if (y === null) {
                    this.root = node;
                } else if (node.data < y.data) {
                    y.left = node;
                } else {
                    y.right = node;
                }
    
                if (node.parent === null) {
                    node.color = 'black';
                    return;
                }
    
                if (node.parent.parent === null) {
                    return;
                }
    
                this.fixInsert(node);
            }
    
            // Inorder Traversal

            <article id="counting-sort">
                <h2>Counting Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="counting-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayCounting()">Generate Random Array</button>
                        <button onclick="countingSort()">Counting Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Counting Sort Algorithm</h3>
                    <p>Counting Sort is an integer sorting algorithm that counts the occurrences of each value in the input array and uses this information to place each value in its correct position.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    sorted_arr = []
    for i, cnt in enumerate(count):
        sorted_arr.extend([i] * cnt)
    
    return sorted_arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = counting_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

        </div>

        <footer id="footer">
            <p>&copy; XYRB</p>
        </footer>
    </div>

    <div id="bg"></div>
</body>
</html>